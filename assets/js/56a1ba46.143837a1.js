"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[621],{9788:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var t=i(4848),o=i(8453);const s={sidebar_position:1},a="Introduction",r={id:"intro",title:"Introduction",description:"This library provides a Kotlin DSL to simplify and enhance the readability of code",source:"@site/versioned_docs/version-1.0.4/intro.md",sourceDirName:".",slug:"/intro",permalink:"/rest-docs-kdsl/docs/intro",draft:!1,unlisted:!1,tags:[],version:"1.0.4",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Getting Started",permalink:"/rest-docs-kdsl/docs/category/getting-started"}},c={},d=[{value:"Existing Issues",id:"existing-issues",level:2},{value:"1. Complex Code Structure",id:"1-complex-code-structure",level:3},{value:"2. Inconvenience of Checking API Specifications",id:"2-inconvenience-of-checking-api-specifications",level:3},{value:"3. Maintenance Challenges",id:"3-maintenance-challenges",level:3},{value:"Improvements",id:"improvements",level:2},{value:"1. Simplification with Kotlin DSL",id:"1-simplification-with-kotlin-dsl",level:3},{value:"2. Ease of Checking API Specifications",id:"2-ease-of-checking-api-specifications",level:3},{value:"3. Detecting Changes at Compile Time",id:"3-detecting-changes-at-compile-time",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,t.jsx)(n.p,{children:"This library provides a Kotlin DSL to simplify and enhance the readability of code\nused for documenting APIs with Spring REST Docs."}),"\n",(0,t.jsxs)(n.p,{children:["Using ",(0,t.jsx)(n.a,{href:"https://kotlinlang.org/docs/ksp-overview.html",children:"KSP"}),", the library analyzes Spring handlers at compile time\nand generates DSL classes for each handler.\nThese generated DSL classes allow you to write Spring REST Docs test code\nand generate adoc files for each API."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"existing-issues",children:"Existing Issues"}),"\n",(0,t.jsx)(n.h3,{id:"1-complex-code-structure",children:"1. Complex Code Structure"}),"\n",(0,t.jsx)(n.p,{children:"Let's consider documenting an API that requires one query parameter in the request\nand responds with a JSON body containing two fields. Using Spring REST Docs, the code might look like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'MockMvcRestDocumentation.document(\n    "identifier",\n    RequestDocumentation.queryParameters(\n        RequestDocumentation.parameterWithName("param1")\n            .optional()\n            .description("param1"),\n    ),\n    PayloadDocumentation.responseFields(\n        PayloadDocumentation.fieldWithPath("field1")\n            .type(JsonFieldType.STRING)\n            .description("field1"),\n        PayloadDocumentation.fieldWithPath("field2")\n            .type(JsonFieldType.NUMBER)\n            .attributes(Attributes.key("format").value("number"))\n            .description("field2"),\n    ),    \n)\n'})}),"\n",(0,t.jsx)(n.p,{children:"Even for a simple API like this, you need to write multiple lines of code."}),"\n",(0,t.jsx)(n.p,{children:"Now imagine documenting an API with a large number of request and response elements.\nThe source code could easily extend to dozens or even hundreds of lines, making it difficult to maintain.\nAdditionally, writing the documentation is cumbersome due to the numerous packages that need to be imported."}),"\n",(0,t.jsx)(n.h3,{id:"2-inconvenience-of-checking-api-specifications",children:"2. Inconvenience of Checking API Specifications"}),"\n",(0,t.jsx)(n.p,{children:"When documenting an API after it has been developed, as opposed to writing test code first,\nyou need to check the handler code to recall the request parameters and response fields.\nWithout remembering the specifics of the API, you must manually verify each field's name while writing the documentation."}),"\n",(0,t.jsx)(n.h3,{id:"3-maintenance-challenges",children:"3. Maintenance Challenges"}),"\n",(0,t.jsx)(n.p,{children:"Ideally, APIs should not change frequently.\nHowever, if the API changes and the test code isn\u2019t updated first,\nyou\u2019ll need to update the documentation code accordingly.\nIn such cases, you have to find the corresponding part of the API documentation manually\nor correct it based on errors in the actual test results."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"improvements",children:"Improvements"}),"\n",(0,t.jsx)(n.h3,{id:"1-simplification-with-kotlin-dsl",children:"1. Simplification with Kotlin DSL"}),"\n",(0,t.jsx)(n.p,{children:"DSL stands for Domain Specific Language, which refers to a language tailored to a specific domain."}),"\n",(0,t.jsx)(n.p,{children:"Kotlin supports features like extension function, infix notation, functional programming, and operator overloading,\nand more, which can be leveraged to create DSLs\nThis library uses these features of Kotlin to simplify verbose Spring REST Docs code into a DSL\ntailored to the Spring REST Docs domain."}),"\n",(0,t.jsx)(n.p,{children:"Let\u2019s rewrite the previous Spring REST Docs example using the Kotlin DSL provided by this library."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'document(ExampleApiSpec("identifier")) {\n    queryParameters {\n        param1 means "param1" isOptional true\n    }\n    responseBody {\n        field1 means "field1" typeOf STRING\n        field2 means "field2" typeOf NUMBER formattedAs "number"\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"This code is much more readable and provides clear descriptions for each field."}),"\n",(0,t.jsx)(n.h3,{id:"2-ease-of-checking-api-specifications",children:"2. Ease of Checking API Specifications"}),"\n",(0,t.jsx)(n.p,{children:"All DSLs can be written based on Kotlin's functional programming,\nwith each function having a specific DSL class as its receiver."}),"\n",(0,t.jsxs)(n.p,{children:["In the example above, ",(0,t.jsx)(n.code,{children:"queryParameters"})," and ",(0,t.jsx)(n.code,{children:"responseBody"})," functions are member functions of the DSL class ",(0,t.jsx)(n.code,{children:"ExampleApiSpec"}),",\nand the second parameter of the ",(0,t.jsx)(n.code,{children:"document"})," function is a function with ",(0,t.jsx)(n.code,{children:"ExampleApiSpec"})," as its receiver."]}),"\n",(0,t.jsxs)(n.p,{children:["Thus, by leveraging the code completion feature of the IDE,\nyou can easily verify the API specifications using the ",(0,t.jsx)(n.code,{children:"this"})," keyword."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'document(ExampleApiSpec("identifier")) {\n    this.queryParameters {\n        this.param1 means "param1" isOptional true\n    }\n    this.responseBody {\n        this.field1 means "field1" typeOf STRING\n        this.field2 means "field2" typeOf NUMBER formattedAs "number"\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["When you type the ",(0,t.jsx)(n.code,{children:"this"})," keyword, the IDE's code completion will show the callable ",(0,t.jsx)(n.code,{children:"queryParameters"})," and ",(0,t.jsx)(n.code,{children:"responseBody"})," functions.\nSimilarly, you can view all member properties like ",(0,t.jsx)(n.code,{children:"param1"})," and ",(0,t.jsx)(n.code,{children:"field1"})," within each function."]}),"\n",(0,t.jsx)(n.h3,{id:"3-detecting-changes-at-compile-time",children:"3. Detecting Changes at Compile Time"}),"\n",(0,t.jsx)(n.p,{children:"This library uses KSP to generate DSL-related implementations at compile time.\nThis allows you to identify changes through compile errors rather than having to run tests,\nmaking it easier to maintain the documentation code."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var t=i(6540);const o={},s=t.createContext(o);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);