"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[172],{5940:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var t=i(4848),s=i(8453);const a={sidebar_position:2},r="DSL Generation Conditions",o={id:"guides/dsl-generation-condition",title:"DSL Generation Conditions",description:"This library analyzes handlers and generates DSL interface implementations based on the analysis.",source:"@site/versioned_docs/version-1.0.4/guides/dsl-generation-condition.md",sourceDirName:"guides",slug:"/guides/dsl-generation-condition",permalink:"/rest-docs-kdsl/docs/guides/dsl-generation-condition",draft:!1,unlisted:!1,tags:[],version:"1.0.4",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"DSL Interface",permalink:"/rest-docs-kdsl/docs/guides/dsl-interface"}},d={},l=[{value:"Handler Determination Conditions",id:"handler-determination-conditions",level:2},{value:"Component Determination Conditions",id:"component-determination-conditions",level:2},{value:"Request Components",id:"request-components",level:3},{value:"Path Variables",id:"path-variables",level:4},{value:"Query Parameters",id:"query-parameters",level:4},{value:"Parts",id:"parts",level:4},{value:"Headers",id:"headers",level:4},{value:"Cookies",id:"cookies",level:4},{value:"Body",id:"body",level:4},{value:"Response Components",id:"response-components",level:3},{value:"Headers",id:"headers-1",level:4},{value:"Cookies",id:"cookies-1",level:4},{value:"Body",id:"body-1",level:4}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"dsl-generation-conditions",children:"DSL Generation Conditions"})}),"\n",(0,t.jsx)(n.p,{children:"This library analyzes handlers and generates DSL interface implementations based on the analysis."}),"\n",(0,t.jsxs)(n.p,{children:["Currently, class and function symbols are analyzed using ",(0,t.jsx)(n.a,{href:"https://kotlinlang.org/docs/ksp-overview.html",children:"KSP (Kotlin Symbol Processing)"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"This section explains how symbols are determined and how DSL implementations are generated based on them."}),"\n",(0,t.jsx)(n.h2,{id:"handler-determination-conditions",children:"Handler Determination Conditions"}),"\n",(0,t.jsxs)(n.p,{children:["When a function is identified as a handler, an implementation of ",(0,t.jsx)(n.code,{children:"ApiSpec"})," is generated."]}),"\n",(0,t.jsxs)(n.p,{children:["This library determines whether a specific function is a handler\nbased on the ",(0,t.jsx)(n.a,{href:"https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-requestmapping.html",children:"Mapping Requests"})," in Spring Web MVC.\nThe conditions are as follows:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["The class where the handler is declared must have the ",(0,t.jsx)(n.code,{children:"@RestController"})," or ",(0,t.jsx)(n.code,{children:"@Controller"})," annotation."]}),"\n",(0,t.jsxs)(n.li,{children:["If the class is annotated with ",(0,t.jsx)(n.code,{children:"@RestController"}),", the function must have a ",(0,t.jsx)(n.a,{href:"https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-requestmapping.html#mvc-ann-requestmapping-annotation",children:"request mapping annotation"})," from Spring."]}),"\n",(0,t.jsxs)(n.li,{children:["If the class is annotated with ",(0,t.jsx)(n.code,{children:"@Controller"}),", the function must have both the ",(0,t.jsx)(n.code,{children:"@ResponseBody"})," annotation and a request mapping annotation."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"component-determination-conditions",children:"Component Determination Conditions"}),"\n",(0,t.jsxs)(n.p,{children:["For functions identified as handlers, the function\u2019s annotations, parameters,\nand return types are analyzed to determine the appropriate HTTP components.\nEach determined element is converted into a ",(0,t.jsx)(n.code,{children:"HandlerElement"})," implementation.\nDepending on the type of implementation,\nit is declared as a member property of the appropriate ",(0,t.jsx)(n.code,{children:"ApiComponent"})," implementation with an ",(0,t.jsx)(n.code,{children:"ApiField"})," type."]}),"\n",(0,t.jsxs)(n.p,{children:["Except for cases where values cannot be determined at compile time,\ncomponents are determined based on ",(0,t.jsx)(n.a,{href:"https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods.html",children:"Handler Methods"})," in Spring Web MVC."]}),"\n",(0,t.jsx)(n.h3,{id:"request-components",children:"Request Components"}),"\n",(0,t.jsx)(n.h4,{id:"path-variables",children:"Path Variables"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["If a parameter in the handler function is annotated with ",(0,t.jsx)(n.code,{children:"@PathVariable"}),", it is identified as a path variable.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The parameter type must be a Java or Kotlin API type or an Enum."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"query-parameters",children:"Query Parameters"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["If a parameter in the handler function is annotated with ",(0,t.jsx)(n.code,{children:"@RequestParam"}),", it is identified as a query parameter.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The parameter type must be a Java or Kotlin API type or an Enum."}),"\n",(0,t.jsxs)(n.li,{children:["The name of the query parameter is determined by the initialized value of the ",(0,t.jsx)(n.code,{children:"name"})," or ",(0,t.jsx)(n.code,{children:"value"})," attribute of the ",(0,t.jsx)(n.code,{children:"@RequestParam"})," annotation."]}),"\n",(0,t.jsx)(n.li,{children:"If this is not applicable, the name of the parameter is used as the query parameter name."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["If a parameter in the handler function is annotated with ",(0,t.jsx)(n.code,{children:"@ModelAttribute"}),", all properties declared in that parameter type are identified as query parameters.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The parameter type must not be a Java or Kotlin API type or an Enum."}),"\n",(0,t.jsx)(n.li,{children:"The name of each property is used as the query parameter name."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["If a parameter in the handler function is not annotated, it is identified as a query parameter.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The parameter type must not be a Spring or Servlet API type."}),"\n",(0,t.jsx)(n.li,{children:"If the parameter type is a Java or Kotlin API type or an Enum, it is analyzed as a single parameter, and the parameter name is used as the query parameter name."}),"\n",(0,t.jsx)(n.li,{children:"If the parameter type is another type, it is analyzed as an object parameter, and the name of each property declared in that parameter type is used as the query parameter name."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"parts",children:"Parts"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["If a parameter in the handler function is annotated with ",(0,t.jsx)(n.code,{children:"@RequestPart"}),", it is identified as a part.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The parameter type must be a Java, Kotlin, Spring API type, or an Enum."}),"\n",(0,t.jsxs)(n.li,{children:["The name of the part is determined by the initialized value of the ",(0,t.jsx)(n.code,{children:"name"})," or ",(0,t.jsx)(n.code,{children:"value"})," attribute of the ",(0,t.jsx)(n.code,{children:"@RequestPart"})," annotation."]}),"\n",(0,t.jsx)(n.li,{children:"If this is not applicable, the name of the parameter is used as the part name."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"headers",children:"Headers"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["If a parameter in the handler function is annotated with ",(0,t.jsx)(n.code,{children:"@RequestHeader"}),", it is identified as a header.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The parameter type must be a Java or Kotlin API type or an Enum."}),"\n",(0,t.jsxs)(n.li,{children:["The name of the header is determined by the initialized value of the ",(0,t.jsx)(n.code,{children:"name"})," or ",(0,t.jsx)(n.code,{children:"value"})," attribute of the ",(0,t.jsx)(n.code,{children:"@RequestHeader"})," annotation."]}),"\n",(0,t.jsx)(n.li,{children:"If this is not applicable, the name of the parameter is used as the header name."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["If the handler function is annotated with ",(0,t.jsx)(n.code,{children:"@RequestHeaderDocs"}),", all the strings in the ",(0,t.jsx)(n.code,{children:"name"})," or ",(0,t.jsx)(n.code,{children:"value"})," attribute of the annotation are identified as headers."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"cookies",children:"Cookies"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["If a parameter in the handler function is annotated with ",(0,t.jsx)(n.code,{children:"@CookieValue"}),", it is identified as a cookie.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The parameter type must be a Java or Kotlin API type or an Enum."}),"\n",(0,t.jsxs)(n.li,{children:["The name of the cookie is determined by the initialized value of the ",(0,t.jsx)(n.code,{children:"name"})," or ",(0,t.jsx)(n.code,{children:"value"})," attribute of the ",(0,t.jsx)(n.code,{children:"@CookieValue"})," annotation."]}),"\n",(0,t.jsx)(n.li,{children:"If this is not applicable, the name of the parameter is used as the cookie name."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["If the handler function is annotated with ",(0,t.jsx)(n.code,{children:"@RequestCookieDocs"}),", all the strings in the ",(0,t.jsx)(n.code,{children:"name"})," or ",(0,t.jsx)(n.code,{children:"value"})," attribute of the annotation are identified as cookies."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"body",children:"Body"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["If a parameter in the handler function is annotated with ",(0,t.jsx)(n.code,{children:"@RequestBody"}),", it is identified as the request body.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The parameter type must not be a single primitive parameter.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The parameter type must not be a Spring, Servlet API, or Kotlin built-in type."}),"\n",(0,t.jsxs)(n.li,{children:["If the type is a collection type such as ",(0,t.jsx)(n.code,{children:"Array"}),", ",(0,t.jsx)(n.code,{children:"List"}),", or ",(0,t.jsx)(n.code,{children:"Set"}),", where JSON is deserialized, the type parameter must satisfy the above conditions."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["The name of each property declared in the parameter type is used as the field name.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If the property type is not a single primitive, the name of each property declared in the nested type is used as the field name."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"response-components",children:"Response Components"}),"\n",(0,t.jsx)(n.h4,{id:"headers-1",children:"Headers"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["If the handler function is annotated with ",(0,t.jsx)(n.code,{children:"@ResponseHeaderDocs"}),", all the strings in the ",(0,t.jsx)(n.code,{children:"name"})," or ",(0,t.jsx)(n.code,{children:"value"})," attribute of the annotation are identified as headers."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"cookies-1",children:"Cookies"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["If the handler function is annotated with ",(0,t.jsx)(n.code,{children:"@ResponseCookieDocs"}),", all the strings in the ",(0,t.jsx)(n.code,{children:"name"})," or ",(0,t.jsx)(n.code,{children:"value"})," attribute of the annotation are identified as cookies."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"body-1",children:"Body"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["If the return type of the handler function is not a Spring or Servlet API type, and it is not a Kotlin built-in type, the return type is analyzed as the response body.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If the type is a collection type such as ",(0,t.jsx)(n.code,{children:"Array"}),", ",(0,t.jsx)(n.code,{children:"List"}),", or ",(0,t.jsx)(n.code,{children:"Set"}),", where JSON is deserialized, the type parameter must satisfy the above conditions."]}),"\n",(0,t.jsxs)(n.li,{children:["The name of each property declared in the return type is used as the field name.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If the property type is not a single primitive, the name of each property declared in the nested type is used as the field name."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"ResponseEntity"})," type in the Spring API is also analyzed as a body.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The type parameter of ",(0,t.jsx)(n.code,{children:"ResponseEntity"})," must not be a Spring, Servlet API, or Kotlin built-in type."]}),"\n",(0,t.jsxs)(n.li,{children:["The name of each property declared in the type parameter is used as the field name.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If the property type is not a single primitive, the name of each property declared in the nested type is used as the field name."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(6540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);